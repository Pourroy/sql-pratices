-- UTILIZANDO WHERE PARA FILTRAGEM DE PREÇO
SELECT 
	PRODUCT_ID,
	DESCRIPTION,
	PRICE,
	PRICE * 1.07 AS TAXED_PRICE
FROM PRODUCT
WHERE PRICE < 13 AND TAXED_PRICE < 15

--FILTRAR PESQUISA POR TUDO ANTES E DEPOIS DE 2010 ( NÃO INCLUSO 2010 )
SELECT * FROM station_data
WHERE year <> 2010;

--MESMA COISA DO ACIMA, PORÉM LÓGICA DE BUSCA É TUDO QUE FOR DIFERENTE DE 2010
SELECT * FROM station_data
WHERE year != 2010;


--FILTRANDO POR UM INTERVALO COM 2 PONTOS DE DELIMITAÇÃO COM 'BETWEEN' (INCLUSOS 2005 E 2010)
SELECT * FROM station_data
WHERE year BETWEEN  2005 and 2010

-- MESMA COISA PORÉM USANDO '>=',  'AND',  '<=''
SELECT * FROM station_data
WHERE year >=  2005 AND year <= 2010


-- FILTRAGEM USANDO 'OR' PARA ESPECIFICAR VALORES
SELECT * FROM station_data
WHERE MONTH  = 3
OR MONTH = 6
OR MONTH = 9
OR MONTH = 12

-- FAZ O MESMO QUE O ANTERIOR, PORÉM MENOS VERBOSO E MAIS LEGÍVEL UTILIZANDO O 'IN'
SELECT * FROM station_data
WHERE MONTH  IN(3,6,9,12)

-- FAZ A FILTRAGEM DE TUDO QUE FOR DIFERENTE DOS PARAMETROS FORNECIDOS A  'NOT IN'
SELECT * FROM station_data
WHERE MONTH NOT IN(3,6,9,12)

-- FAZ A FILTRAGEM DE TUDO QUE FOR DIVISÍVEL POR 3
SELECT * FROM station_data
WHERE MONTH % 3 = 0

-- FILTRA POR REPORT CODE PROCURANDO UM = AO TEXTO INFORMADO
SELECT * FROM STATION_DATA
WHERE report_code  = '513A63'

-- FILTRA PROCURANDO POR TODOS OS REPORTS INFORMADOS DENTRO DO IN
SELECT * FROM STATION_DATA
WHERE report_code  IN ('513A63', '1F8A7B', 'EF616A')

-- FILTRA POR REPORT CODES EM QUE O NUMERO DE CARACTERES DO CÓDIGO SEJA DIFERENTE DE 6
SELECT * FROM STATION_DATA
WHERE length(report_code) != 6

--FILTRA POR report_code QUE INCIE COM A LETRA A
SELECT * FROM STATION_DATA
WHERE report_code  LIKE  'A%'

-- FILTRA POR report_code  QUE INICIE COM B, TENHA COMO TERCEIRA LETRA C E A ÚLTIMA A, PODENDO PREENCHER A SEGUNDA E QUARTA POSIÇÃO COM QUALQUER VALOR
SELECT * FROM STATION_DATA
WHERE report_code  LIKE  'B_C_A%'

-- FILTRANDO COM VALORES BOOLEANOS
SELECT * FROM STATION_DATA
WHERE tornado = true AND hail = true;

-- MESMA COISA DO EXEMPLO ANTERIOR PORÉM, OMITINDO O TRUE
SELECT * FROM STATION_DATA
WHERE tornado AND hail;

-- USANDO VALORES BINÁRIOS PARA DETERMINAR VERDADEIRO = 1 E FALSO = 0
SELECT * FROM STATION_DATA
WHERE tornado = 1 AND hail = 0;

-- USANDO NOT PARA EXPLICITAR QUE BUSCA POR FALSE EM UM CAMPO ESPECÍFICO
SELECT * FROM STATION_DATA
WHERE NOT tornado AND NOT hail;

-- FILTRANDO POR OCORRÊNCIAS NULAS COM 'IS NULL'
SELECT * FROM STATION_DATA
WHERE snow_depth IS NULL

-- FILTRANDO POR OCORRÊNCIAS NULAS COM 'IS NOT NULL'
SELECT * FROM STATION_DATA
WHERE snow_depth IS NOT NULL 
AND precipitation <= 0.5

-- FILTRANDO POR OCORRÊNCIAS NULAS E TRANSFORMANDO TODAS EM OUTRO VALOR COM COALESCE
-- NESTE CASO QUALQUER precipitation  NULL SERÁ TRANSFORMADA EM 0
SELECT * FROM STATION_DATA
WHERE coalesce(precipitation, 0) <= 0.5

--COALESCE  DIRETO NO SELECT PARA REPRESENTAR UM CAMPO
SELECT report_code, 
	coalesce(precipitation, 0) as rainfall
FROM STATION_DATA

--AGRUPANDO DIFERENTES CONDICIONADORES
SELECT * FROM STATION_DATA
WHERE rain = 1 AND temperature <= 32
OR snow_depth > 0

-- AGRUPANDO DE FORMA MAIS LEGÍVEL
SELECT * FROM STATION_DATA	
WHERE (rain AND temperature <= 32) -- PARA QUE SABERMOS SE HOUVE NEVE, PRECISAMOS QUE ESTEJA CHOVENDO AND A TEMPERATURA SEJA FRIA, ASSIM A CHUVA VIRA NEVE COM CERTEZA
OR snow_depth > 0 -- OU SE HOUVER REGISTRO DE PROFUNDIDADE DE NEVE.
-- SÃO DUAS CONDIÇÕES DIFERENTES QUE ASSEGURAM QUE O QUE É BUSCADO OCORREU
-- LOGO É MELHOR DEIXAR AS CONDIÇÕES ANINHADAS () DE FORMA LEGÍVEL AO INVÉS DE ESCRITAS DE FORMA CURSIVA